# Exercise 11: Conversation-based integration tests

When writing integration tests for message-based systems it's common to make assertions on the results of the whole conversation and not the initial command alone. This part of the tutorial shows how to instrument message handling endpoints so that it's possible for the testing logic to run assertions only after all messages in the conversation have been processed. 

### Goal

The goal of this exercise is to write a single integration test that depends on the processing result of the last message in a conversation. The conversation starts with the `PlaceOrder` command that has a 1 in 20 chance of triggering the final `FinalizeOrder` command or re-sending the same command with `1` seconds delay:

```csharp
if (new Random().Next(0, 20) == 0)
{
    var options = new SendOptions();
    options.DelayDeliveryWith(TimeSpan.FromSeconds(10));

    await context.Send(message, options);
}
else
{
    await context.SendLocal(new FinalizeOrder{Id = message.Id});
}
```

This, causes flakiness in our integration test.

```csharp
[Test]
[TestCaseSource(nameof(TestCases))]
public async Task PlaceOrder()
{
    var message = new PlaceOrder {Id = Guid.NewGuid()};

    await endpoint.Send(message);

    Assert.Contains(message.Id, store.PlacedOrders, "PlaceOrder command should result in order record being stored in the OrderStore");
}
```

Note that the test is being executed 25 times based on the values generated by `TestCases` function:

```
static IEnumerable<string> TestCases => Enumerable.Range(1, 25).Select(n => $"{n:00}");
```

### Step 1

Can we solve the problem with a simple patch? Can we add `Task.Delay` in our test to make it pass consistently?

### Step 2

Let's add behavior to the message processing pipeline in our endpoint to capture identifiers for every incoming message and its resulting outgoing messages and send this data off to a dedicated queue for further processing.
This `TracingBehavior` is registered on the endpoint:

```csharp 
 (endpoint, store) = await Program.StartEndpoint(c =>
{
    c.Pipeline.Register(new TracingBehavior(), "Traces input-output messages");
});
```

TASK: Add the missing logic to the `TracingBehavior` to capture outgoing message identifiers in the `OutgoingMessageIds` property of the `TracingMessage`. Run the test in `Debug` mode to ensure the data is captured.

### Step 3

Tracing messages sent to the `trace` queue will be processed by a dedicated endpoint encapsulated in the `Tracer` class. 

TASK: Create an instance of the `Tracer` class in the `Setup` method of the test and make sure it's properly cleaned up in the `Cleanup` method. 

### Step 4

`Tracer` provides logic to set up conversation tracking and wait until the conversation finishes. In order to set up, the conversation one needs to call the `Prepare` method which returns `conversationId` and `SendOptions` tuple.

TASK: Extend the test code by calling the `tracer.Prepare` and `tracer.WaitUntilFinished` to make sure that test asserts are called at the right time.
